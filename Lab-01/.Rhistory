library(NbClust)      # Xác định số cụm tối ưu
# 2. Nạp dữ liệu IRIS
data(iris)
# Kiểm tra dữ liệu
head(iris)
summary(iris)
str(iris)
# 3. Khám phá dữ liệu
# 3.1. Thống kê mô tả
summary(iris[, 1:4])
# 3.2. Vẽ ma trận đồ thị phân tán
pairs(iris[, 1:4],
main = "Ma trận đồ thị phân tán của dữ liệu IRIS",
pch = 21,
bg = c("red", "green3", "blue")[unclass(iris$Species)])
# Phân cụm dữ liệu IRIS sử dụng thuật toán K-means trên R
# 1. Cài đặt và nạp các gói cần thiết
if (!require(tidyverse)) install.packages("tidyverse")
if (!require(cluster)) install.packages("cluster")
if (!require(factoextra)) install.packages("factoextra")
if (!require(fpc)) install.packages("fpc")
if (!require(NbClust)) install.packages("NbClust")
library(tidyverse)    # Xử lý và vẽ dữ liệu
library(cluster)      # Các thuật toán phân cụm
library(factoextra)   # Trực quan hóa phân cụm
library(fpc)          # Đánh giá phân cụm
library(NbClust)      # Xác định số cụm tối ưu
# 2. Nạp dữ liệu IRIS
data(iris)
# Kiểm tra dữ liệu
head(iris)
summary(iris)
str(iris)
# 3. Khám phá dữ liệu
# 3.1. Thống kê mô tả
summary(iris[, 1:4])
# 3.2. Vẽ ma trận đồ thị phân tán
pairs(iris[, 1:4],
main = "Ma trận đồ thị phân tán của dữ liệu IRIS",
pch = 21,
bg = c("red", "green3", "blue")[unclass(iris$Species)])
legend("bottom",
legend = levels(iris$Species),
col = c("red", "green3", "blue"),
pch = 16,
bty = "n",
xpd = TRUE)
# 3.3. Xem phân bố của từng đặc trưng theo loài
par(mfrow = c(2, 2))
for(i in 1:4) {
boxplot(iris[,i] ~ iris$Species,
main = names(iris)[i],
xlab = "Loài",
ylab = "Giá trị",
col = c("red", "green3", "blue"))
}
par(mfrow = c(1, 1))
# 4. Tiền xử lý dữ liệu
# 4.1. Chỉ sử dụng đặc trưng số
iris_features <- iris[, 1:4]
# 4.2. Chuẩn hóa dữ liệu (quan trọng cho K-means)
iris_scaled <- scale(iris_features)
summary(iris_scaled)
# 5. Xác định số cụm K tối ưu
# 5.1. Phương pháp Elbow
set.seed(123)
# Tính WSS (Within-cluster Sum of Squares) cho các giá trị K từ 1 đến 10
wss <- numeric(10)
for (i in 1:10) {
kmeans_result <- kmeans(iris_scaled, centers = i, nstart = 25)
wss[i] <- kmeans_result$tot.withinss
}
# Vẽ đồ thị Elbow
plot(1:10, wss, type = "b", pch = 19,
xlab = "Số cụm (K)",
ylab = "Tổng bình phương khoảng cách trong cụm (WSS)",
main = "Phương pháp Elbow")
abline(v = 3, col = "red", lty = 2)
# 5.2. Phương pháp Silhouette
fviz_nbclust(iris_scaled, kmeans, method = "silhouette") +
labs(title = "Phương pháp Silhouette")
# 5.3. Phương pháp Gap Statistic
set.seed(123)
gap_stat <- clusGap(iris_scaled, FUN = kmeans, nstart = 25, K.max = 10, B = 50)
fviz_gap_stat(gap_stat) +
labs(title = "Phương pháp Gap Statistic")
# 5.4. Sử dụng NbClust để đánh giá đa tiêu chí
set.seed(123)
nb <- NbClust(iris_scaled, distance = "euclidean", min.nc = 2, max.nc = 10,
method = "kmeans", index = "all")
# Hiển thị biểu đồ số cụm được đề xuất
barplot(table(nb$Best.n[1,]),
xlab = "Số cụm (K)",
ylab = "Số lượng chỉ số đề xuất",
main = "Số lượng chỉ số đề xuất cho mỗi K")
# 6. Áp dụng thuật toán K-means với K=3 (biết trước rằng IRIS có 3 loài)
set.seed(123)
k <- 3
kmeans_result <- kmeans(iris_scaled, centers = k, nstart = 25)
# 7. Trực quan hóa kết quả phân cụm
# 7.1. Thêm nhãn cụm vào dữ liệu gốc
iris_clustered <- cbind(iris, cluster = as.factor(kmeans_result$cluster))
head(iris_clustered)
# 7.2. Vẽ đồ thị phân cụm
fviz_cluster(kmeans_result, data = iris_scaled,
palette = c("#FF0000", "#00FF00", "#0000FF"),
ellipse.type = "convex",
star.plot = TRUE,
repel = TRUE,
ggtheme = theme_minimal()) +
labs(title = "Kết quả phân cụm K-means trên dữ liệu IRIS",
subtitle = paste("K =", k)) +
theme(plot.title = element_text(hjust = 0.5),
plot.subtitle = element_text(hjust = 0.5))
# 7.3. Vẽ đồ thị so sánh kết quả phân cụm với nhãn thực tế
# Tạo bảng tần suất
cluster_vs_species <- table(kmeans_result$cluster, iris$Species)
print(cluster_vs_species)
# Vẽ heat map
heatmap(cluster_vs_species,
Rowv = NA, Colv = NA,
col = viridis::viridis(100),
main = "So sánh cụm với loài thực tế",
xlab = "Loài",
ylab = "Cụm")
# 8. Đánh giá chất lượng phân cụm
# ======================================================================================
# PHẦN 8 GIẢI THÍCH: Chúng ta sẽ đánh giá thuật toán K-means theo hai cách:
# 1) Đánh giá nội tại: Chỉ dựa vào dữ liệu, không cần biết nhãn thực tế
# 2) Đánh giá ngoại lai: So sánh kết quả phân cụm với nhãn loài thực tế
# ======================================================================================
# 8.1. Đánh giá nội tại (Internal Evaluation)
cat("\n===== ĐÁNH GIÁ NỘI TẠI (KHÔNG CẦN BIẾT NHÃN THỰC TẾ) =====\n\n")
# 8.1.1. Inertia (Total Within-Cluster Sum of Squares)
# GIẢI THÍCH: WSS đo lường mức độ gắn kết trong mỗi cụm. Giá trị càng thấp càng tốt.
cat("1. Tổng bình phương khoảng cách trong cụm (Total WSS):", kmeans_result$tot.withinss, "\n")
cat("   Ý nghĩa: Đo lường mức độ gắn kết trong cụm, giá trị càng thấp càng tốt.\n")
cat("   Giải thích: Cụm càng chặt chẽ, các điểm càng gần nhau thì WSS càng thấp.\n\n")
# 8.1.2. Silhouette Score
# GIẢI THÍCH: Silhouette đo lường mức độ tương tự của một điểm với cụm của nó so với các cụm khác.
# Giá trị từ -1 đến 1, càng gần 1 càng tốt.
sil <- silhouette(kmeans_result$cluster, dist(iris_scaled))
avg_sil <- mean(sil[, 3])
cat("2. Hệ số Silhouette trung bình:", avg_sil, "\n")
cat("   Ý nghĩa: Đo lường mức độ phù hợp của điểm dữ liệu với cụm của nó.\n")
cat("   Thang đo: Từ -1 đến 1, càng gần 1 càng tốt.\n")
cat("   Giải thích: \n")
cat("   - Giá trị gần 1: Điểm dữ liệu được gán đúng cụm\n")
cat("   - Giá trị gần 0: Điểm dữ liệu nằm ở ranh giới giữa hai cụm\n")
cat("   - Giá trị gần -1: Điểm dữ liệu có thể bị gán sai cụm\n\n")
# Vẽ đồ thị silhouette
cat("   Đang vẽ biểu đồ Silhouette để trực quan hóa...\n\n")
fviz_silhouette(sil) +
labs(title = "Biểu đồ Silhouette",
subtitle = "Giá trị càng gần 1 càng tốt") +
theme(plot.title = element_text(hjust = 0.5),
plot.subtitle = element_text(hjust = 0.5))
# 8.1.3. Calinski-Harabasz Index (CH Index)
# GIẢI THÍCH: CH Index đo lường tỷ lệ giữa phương sai giữa các cụm và phương sai trong cụm.
# Giá trị càng cao càng tốt.
ch_index <- calinhara(iris_scaled, kmeans_result$cluster)
cat("3. Chỉ số Calinski-Harabasz:", ch_index, "\n")
cat("   Ý nghĩa: Đo lường tỷ lệ giữa phương sai giữa các cụm và phương sai trong cụm.\n")
cat("   Thang đo: Giá trị dương, càng cao càng tốt.\n")
cat("   Giải thích: Chỉ số cao cho thấy các cụm tách biệt rõ ràng và chặt chẽ bên trong.\n\n")
# 8.1.4. Davies-Bouldin Index
# GIẢI THÍCH: Davies-Bouldin Index đo lường mức độ tương tự giữa các cụm.
# Giá trị càng thấp càng tốt.
davies_bouldin <- cluster.stats(dist(iris_scaled), kmeans_result$cluster)$db
cat("4. Chỉ số Davies-Bouldin:", davies_bouldin, "\n")
cat("   Ý nghĩa: Đo lường mức độ tương tự giữa các cụm.\n")
cat("   Thang đo: Giá trị dương, càng thấp càng tốt.\n")
cat("   Giải thích: Chỉ số thấp cho thấy các cụm được phân tách tốt và ít chồng chéo.\n\n")
# Đơn giản hóa: Tổng hợp đánh giá nội tại
cat("Tổng hợp đánh giá nội tại:\n")
if (avg_sil > 0.5) {
cat("   Chất lượng phân cụm TỐT dựa trên chỉ số Silhouette (", round(avg_sil, 2), " > 0.5)\n")
} else if (avg_sil > 0.25) {
cat("   Chất lượng phân cụm TRUNG BÌNH dựa trên chỉ số Silhouette (", round(avg_sil, 2), ")\n")
} else {
cat("   Chất lượng phân cụm KÉM dựa trên chỉ số Silhouette (", round(avg_sil, 2), " < 0.25)\n")
}
if (davies_bouldin < 0.8) {
cat("   Các cụm TÁCH BIỆT TỐT dựa trên chỉ số Davies-Bouldin (", round(davies_bouldin, 2), " < 0.8)\n\n")
} else {
cat("   Các cụm có thể có sự CHỒNG CHÉO dựa trên chỉ số Davies-Bouldin (", round(davies_bouldin, 2), " >= 0.8)\n\n")
}
plot(1:10, wss, type = "b", pch = 19,
xlab = "Số cụm (K)",
ylab = "Tổng bình phương khoảng cách trong cụm (WSS)",
main = "Phương pháp Elbow")
abline(v = 3, col = "red", lty = 2)
# 5.2. Phương pháp Silhouette
fviz_nbclust(iris_scaled, kmeans, method = "silhouette") +
labs(title = "Phương pháp Silhouette")
# 5.3. Phương pháp Gap Statistic
set.seed(123)
gap_stat <- clusGap(iris_scaled, FUN = kmeans, nstart = 25, K.max = 10, B = 50)
fviz_gap_stat(gap_stat) +
labs(title = "Phương pháp Gap Statistic")
# 5.4. Sử dụng NbClust để đánh giá đa tiêu chí
set.seed(123)
nb <- NbClust(iris_scaled, distance = "euclidean", min.nc = 2, max.nc = 10,
method = "kmeans", index = "all")
# Hiển thị biểu đồ số cụm được đề xuất
barplot(table(nb$Best.n[1,]),
xlab = "Số cụm (K)",
ylab = "Số lượng chỉ số đề xuất",
main = "Số lượng chỉ số đề xuất cho mỗi K")
if (!require(tidyverse)) install.packages("tidyverse")
if (!require(cluster)) install.packages("cluster")
if (!require(factoextra)) install.packages("factoextra")
if (!require(fpc)) install.packages("fpc")
if (!require(NbClust)) install.packages("NbClust")
library(tidyverse)    # Xử lý và vẽ dữ liệu
library(cluster)      # Các thuật toán phân cụm
library(factoextra)   # Trực quan hóa phân cụm
library(fpc)          # Đánh giá phân cụm
library(NbClust)      # Xác định số cụm tối ưu
# 5.1. Phương pháp Elbow (Khuỷu tay)
# GIẢI THÍCH: Phương pháp này vẽ đồ thị WSS (Within-cluster Sum of Squares) theo K
# và tìm điểm "khuỷu tay" - điểm mà WSS bắt đầu giảm chậm lại
cat("1. PHƯƠNG PHÁP ELBOW (KHUỶU TAY):\n")
cat("   Ý tưởng: Khi tăng số cụm K, WSS (tổng bình phương khoảng cách trong cụm) giảm.\n")
cat("   Chúng ta tìm điểm 'khuỷu tay' - nơi mà việc tăng K không làm giảm WSS đáng kể nữa.\n\n")
set.seed(123)
# Tính WSS (Within-cluster Sum of Squares) cho các giá trị K từ 1 đến 10
wss <- numeric(10)
for (i in 1:10) {
kmeans_result <- kmeans(iris_scaled, centers = i, nstart = 25)
wss[i] <- kmeans_result$tot.withinss
}
# Vẽ đồ thị Elbow
plot(1:10, wss, type = "b", pch = 19,
xlab = "Số cụm (K)",
ylab = "Tổng bình phương khoảng cách trong cụm (WSS)",
main = "Phương pháp Elbow")
grid()
abline(v = 3, col = "red", lty = 2)
text(3.3, wss[1]/2, "K = 3", col = "red")
# Giải thích kết quả
Giải thích kết quả
# Giải thích kết quả
cat("   Quan sát đồ thị Elbow:\n")
cat("   - WSS giảm mạnh khi K tăng từ 1 đến 3\n")
cat("   - Sau K = 3, đường cong dần phẳng ra (hình thành 'khuỷu tay')\n")
cat("   - Điều này gợi ý K = 3 là lựa chọn tốt (đúng với thực tế IRIS có 3 loài)\n\n")
# 5.2. Phương pháp Silhouette
# GIẢI THÍCH: Hệ số Silhouette đo lường mức độ phù hợp của điểm dữ liệu với cụm của nó
# so với các cụm lân cận. Phương pháp này tìm K cho giá trị Silhouette trung bình cao nhất.
cat("2. PHƯƠNG PHÁP SILHOUETTE:\n")
cat("   Ý tưởng: Tìm K cho hệ số Silhouette trung bình cao nhất.\n")
cat("   Hệ số Silhouette đo lường mức độ phù hợp của điểm dữ liệu với cụm của nó.\n\n")
# Tính silhouette score cho các K từ 2 đến 10
cat("   Đang tính toán và vẽ biểu đồ Silhouette cho các giá trị K khác nhau...\n")
fviz_nbclust(iris_scaled, kmeans, method = "silhouette") +
labs(title = "Phương pháp Silhouette",
subtitle = "Chọn K cho giá trị Silhouette cao nhất") +
theme(plot.title = element_text(hjust = 0.5),
plot.subtitle = element_text(hjust = 0.5))
# Giải thích kết quả
cat("   Quan sát đồ thị Silhouette:\n")
cat("   - Trục ngang: Số cụm K\n")
cat("   - Trục dọc: Hệ số Silhouette trung bình\n")
cat("   - Hệ số cao nhất thường ở K = 2, nhưng K = 3 cũng cho kết quả tốt\n")
cat("   - Hệ số Silhouette giảm khi K > 3\n\n")
# 5.4. Sử dụng NbClust để đánh giá đa tiêu chí
# GIẢI THÍCH: NbClust tính toán 30 chỉ số khác nhau và đưa ra K được đề xuất nhiều nhất
cat("4. PHƯƠNG PHÁP ĐÁNH GIÁ ĐA TIÊU CHÍ (NBCLUST):\n")
cat("   Ý tưởng: Sử dụng nhiều chỉ số đánh giá khác nhau (30 chỉ số) để xác định K.\n")
cat("   Chọn K được đề xuất bởi nhiều chỉ số nhất.\n\n")
set.seed(123)
cat("   Đang tính toán 30 chỉ số đánh giá khác nhau (có thể mất vài giây)...\n")
nb <- NbClust(iris_scaled, distance = "euclidean", min.nc = 2, max.nc = 10,
method = "kmeans", index = "all")
# Hiển thị biểu đồ số cụm được đề xuất
cat("   Đang vẽ biểu đồ tổng hợp các chỉ số...\n")
barplot(table(nb$Best.n[1,]),
xlab = "Số cụm (K)",
ylab = "Số lượng chỉ số đề xuất",
main = "Số lượng chỉ số đề xuất cho mỗi K",
col = "steelblue")
grid()
# Giải thích kết quả
cat("   Quan sát biểu đồ tổng hợp:\n")
cat("   - Trục ngang: Số cụm K\n")
cat("   - Trục dọc: Số lượng chỉ số đề xuất K tương ứng\n")
cat("   - K được đề xuất nhiều nhất là lựa chọn tốt (thường là K = 2 hoặc 3)\n\n")
# Tổng hợp kết quả từ 4 phương pháp
cat("TỔNG HỢP KẾT QUẢ XÁC ĐỊNH K TỐI ƯU:\n")
cat("1. Phương pháp Elbow: K = 3\n")
cat("2. Phương pháp Silhouette: K = 2 hoặc 3\n")
cat("3. Phương pháp Gap Statistic: K = 3 hoặc 4\n")
cat("4. Phương pháp đa tiêu chí: K = 2 hoặc 3\n\n")
cat("Kết luận: K = 3 là lựa chọn hợp lý dựa trên đa số phương pháp.\n")
cat("Điều này trùng khớp với thực tế là dữ liệu IRIS có 3 loài.\n\n")
install.packages("ggplot2")
ggplot2
mtcars
# Ví dụ
# Scatter plot
# Sử dụng bộ dữ liệu mtcars
str(mtcars)
# Ví dụ
# Scatter plot
# Sử dụng bộ dữ liệu mtcars
str(mtcars)
ggoplot(data = mtcars,
aes(x=wt , y=mpg)) +
geom_point()
str(mtcars)
ggplot(data = mtcars,
aes(x=wt , y=mpg)) +
geom_point()
ggplot(data = mtcars,aes(x=wt , y=mpg)) +
geom_point()
ggplot(data = mtcars, aes(x = wt, y = mpg)) +
geom_point()
# Load gói vào môi trường R
library(ggplot2)
ggplot(data = mtcars, aes(x = wt, y = mpg)) +
geom_point()
economics
ggplot(data = economics, aes(x = date, y = uempmed)) +
geom_line()
mpg
ggplot(data = mpg, aes(x=class))+
geom_bar()
ggplot(data = mpg, aes(x=class, y=hwy))+
geom_boxplot()
# Biểu đồ mật độ (Density plot)
ggplot(data = mpg, aes(x=hwy))+
geom_density()
ggplot(data = mpg, aes(x=class, y=hwy))+
geom_violin()
ggplot(data = mtcars, aes(x = wt, y = mpg)) +
geom_point()
labs(
title = "Mối quan hệ giữa trọng lượng và hiệu suất nhiên liệu",
)
ggplot(data = mtcars, aes(x = wt, y = mpg)) +
geom_point() +
labs(
title = "Mối quan hệ giữa trọng lượng và hiệu suất nhiên liệu",
)
ggplot(data = mtcars, aes(x = wt, y = mpg)) +
geom_point() +
labs(
title = "Mối quan hệ giữa trọng lượng và hiệu suất nhiên liệu",
subtitle = "Dữ liệu mrcars",
)
ggplot(data = mtcars, aes(x = wt, y = mpg)) +
geom_point() +
labs(
title = "Mối quan hệ giữa trọng lượng và hiệu suất nhiên liệu",
subtitle = "Dữ liệu mrcars",
x = "Trọng lượng (1000 lbs)",
y = "Miles per Gallon",
caption = "Nguồn: Motor Trand, 1974"
)
ggplot(data = mtcars, aes(x = displ, y = hwy, color = class)) +
geom_point() +
scale_color_brewer(palette = "Set1")
ggplot(data = mpg, aes(x = displ, y = hwy, color = class)) +
geom_point() +
scale_color_brewer(palette = "Set1")
labs(
title = "Mối quan hệ giữa trọng lượng và hiệu suất nhiên liệu",
subtitle = "Dữ liệu mrcars",
x = "Trọng lượng (1000 lbs)",
y = "Miles per Gallon",
caption = "Nguồn: Motor Trand, 1974"
)
ggplot(data = mpg, aes(x = displ, y = hwy, color = class)) +
geom_point() +
scale_color_brewer(palette = "Set1")
ggplot(data = mtcars, aes(x = wt, y = mpg)) +
geom_point() +
theme_minimal()
ggplot(data = mtcars, aes(x = wt, y = mpg)) +
geom_point() +
theme_dark()
ggplot(data = mtcars, aes(x = wt, y = mpg)) +
geom_point() +
theme_bw()
ggplot(data = mtcars, aes(x = wt, y = mpg)) +
geom_point() +
theme_void()
# Cài đặt gói ggthemes
install.packages("ggthemes")
library(ggthemes)
library(ggthemes)
ggplot(data = mtcars, aes(x = wt, y = mpg)) +
geom_point() +
labs(
title = "Mối quan hệ giữa trọng lượng và hiệu suất nhiên liệu",
subtitle = "Dữ liệu mrcars",
x = "Trọng lượng (1000 lbs)",
y = "Miles per Gallon",
caption = "Nguồn: Motor Trand, 1974"
) +
theme_excel()
ggplot(data = mtcars, aes(x = wt, y = mpg)) +
geom_point() +
labs(
title = "Mối quan hệ giữa trọng lượng và hiệu suất nhiên liệu",
subtitle = "Dữ liệu mrcars",
x = "Trọng lượng (1000 lbs)",
y = "Miles per Gallon",
caption = "Nguồn: Motor Trand, 1974"
) +
theme_excel_new()
ggplot(data = mtcars, aes(x = wt, y = mpg)) +
geom_point() +
labs(
title = "Mối quan hệ giữa trọng lượng và hiệu suất nhiên liệu",
subtitle = "Dữ liệu mrcars",
x = "Trọng lượng (1000 lbs)",
y = "Miles per Gallon",
caption = "Nguồn: Motor Trand, 1974"
) +
theme_economist()
ggplot(data = mtcars, aes(x = wt, y = mpg)) +
geom_point() +
labs(
title = "Mối quan hệ giữa trọng lượng và hiệu suất nhiên liệu",
subtitle = "Dữ liệu mrcars",
x = "Trọng lượng (1000 lbs)",
y = "Miles per Gallon",
caption = "Nguồn: Motor Trand, 1974"
) +
theme_wsj()
ggplot(data = mtcars, aes(x = wt, y = mpg)) +
geom_point() +
labs(
title = "Mối quan hệ giữa trọng lượng và hiệu suất nhiên liệu",
subtitle = "Dữ liệu mrcars",
x = "Trọng lượng (1000 lbs)",
y = "Miles per Gallon",
caption = "Nguồn: Motor Trand, 1974"
) +
theme_fivethirtyeight()
ggplot(data = mtcars, aes(x = wt, y = mpg)) +
geom_point() +
labs(
title = "Mối quan hệ giữa trọng lượng và hiệu suất nhiên liệu",
subtitle = "Dữ liệu mrcars",
x = "Trọng lượng (1000 lbs)",
y = "Miles per Gallon",
caption = "Nguồn: Motor Trand, 1974"
) +
theme_tufte()
ggplot(data = mtcars, aes(x = wt, y = mpg)) +
geom_point() +
labs(
title = "Mối quan hệ giữa trọng lượng và hiệu suất nhiên liệu",
subtitle = "Dữ liệu mrcars",
x = "Trọng lượng (1000 lbs)",
y = "Miles per Gallon",
caption = "Nguồn: Motor Trand, 1974"
) +
theme_solarized()
ggplot(data = mtcars, aes(x = wt, y = mpg)) +
geom_point() +
labs(
title = "Mối quan hệ giữa trọng lượng và hiệu suất nhiên liệu",
subtitle = "Dữ liệu mrcars",
x = "Trọng lượng (1000 lbs)",
y = "Miles per Gallon",
caption = "Nguồn: Motor Trand, 1974"
) +
theme_minimal() +
theme(
plot.title = element_text(color = "navy", face = "bold", size = 14),
axis.title = element_text(face = "italic"),
axis.text = element_text(color = "darkgrey"),
panel.grid.major = element_line(color = "lightblue", linetype = "dashed"),
panel.grid.minor = element_blank()
)
my_theme <- theme_minimal() +
theme(
plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
plot.subtitle = element_text(hjust = 0.5, color = "grey40"),
axis.title = element_text(face = "italic"),
axis.text = element_text(color = "navy"),
panel.grid.major = element_line(color = "grey90"),
panel.grid.minor = element_blank(),
legend.position = "bottom",
legend.title = element_text(face = "bold")
)
ggplot(data = mtcars, aes(x = wt, y = mpg)) +
geom_point() +
labs(
title = "Mối quan hệ giữa trọng lượng và hiệu suất nhiên liệu",
subtitle = "Dữ liệu mrcars",
x = "Trọng lượng (1000 lbs)",
y = "Miles per Gallon",
caption = "Nguồn: Motor Trand, 1974"
) +
my_theme
<img src="images/img1.png" alt="Mo ta SVM" style="height: 100px; width:100px;"/>
install.packages("tinytex")
install.packages("tinytex")
install.packages("tinytex")
install.packages("tinytex")
install.packages("xfun")
install.packages("xfun")
install.packages(xfun)
install.packages("xfun")
library(xfun)
remove.packages("xfun")
install.packages("xfun")
